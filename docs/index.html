<!DOCTYPE html>
<html lang="en">
  <head>
    <title>EEG signal classification demo</title>
    <!--DO NOT EDIT THIS FILE. Automatically generated by pyjsclient. https://github.com/pbizopoulos/pyjsclient-->
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  </head>
  <body>
    <div id="divInputControl" style="width:256px;height:256px;border-style:solid;position:fixed;top:0px;left:0px;">
      <div>NOT FOR MEDICAL USE. Choose a EEG csv file (.txt,.csv) and classify epilepsy using a DNN.</div>
      <div>
        <a href="https://github.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification">[url]</a>
      </div>
      <div>
        <input accept=".txt,.csv" onchange="signalClassificationLoadView();" type="file">
      </div>
      <div>
        <select id="selectModel" onchange="loadModel(predictionFunction);" style="width:100%;">
          <option>https://raw.githubusercontent.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification-tfjs/master/alexnet-1D/model.json</option>
          <option>https://raw.githubusercontent.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification-tfjs/master/lenet-1D/model.json</option>
          <option>https://raw.githubusercontent.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification-tfjs/master/resnet18-1D/model.json</option>
          <option>https://raw.githubusercontent.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification-tfjs/master/resnet34-1D/model.json</option>
          <option>https://raw.githubusercontent.com/pbizopoulos/signal2image-modules-in-deep-neural-networks-for-eeg-classification-tfjs/master/resnet50-1D/model.json</option>
        </select>
      </div>
    </div>
    <div id="divInput" style="width:256px;height:256px;border-style:solid;position:fixed;top:0px;left:256px;"></div>
    <div id="divOutput" style="width:256px;height:256px;border-style:solid;position:fixed;top:0px;left:512px;"></div>
    <script>const canvasWidth = 256;const canvasHeight = 256;const predictionFunction = signalClassificationPredictView;const classNames = ['Open', 'Closed', 'Healthy', 'Tumor', 'Epilepsy'];
let csvDataset;
let csvDatasetMax;
let csvDatasetMin;
const svgInput = d3.select('#divInput')
    .append('svg')
    .attr('viewBox', [0, 0, canvasWidth, canvasHeight]);
svgInput.append('path')
    .attr('id', 'pathInput')
    .style('fill', 'none')
    .style('stroke', 'blue');
d3.select('#divInput')
    .call(d3.drag()
            .on('start', (event) => {
                event.on('drag', (event) => {
                    const buffer = tf.buffer(csvDataset.shape, csvDataset.dtype, csvDataset.dataSync());
                    buffer.set(csvDatasetMin + csvDatasetMax*(canvasHeight - event.y)/canvasHeight, Math.round(csvDataset.size*(event.x - canvasWidth)/canvasWidth));
                    tf.dispose(csvDataset);
                    csvDataset = buffer.toTensor();
                    d3.select('#pathInput')
                    .attr('d', line(csvDataset.arraySync()));
                    signalClassificationPredictView();
                    });
                }));
const x = d3.scaleLinear()
    .domain([0, 180])
    .range([0, canvasWidth]);
const y = d3.scaleLinear()
    .domain([0, 300])
    .range([canvasHeight, 0]);
const line = d3.line()
    .x((d,i) => x(i))
    .y(d => y(d));

function signalClassificationLoadView() {
        const files = event.currentTarget.files;
        const reader = new FileReader();
        reader.onload = function (e) {
            const text = e.target.result;
            const array = text.match(/\d+(?:\.\d+)?/g).map(Number);
            csvDataset = tf.tensor(array);
            csvDatasetMax = csvDataset.max().arraySync();
            csvDatasetMin = csvDataset.min().arraySync();
            d3.select('#pathInput')
            .attr('d', line(csvDataset.arraySync()));
            signalClassificationPredictView();
            };
        if (files[0]) {
            reader.readAsText(files[0]);
            }
        }

async function signalClassificationPredictView(){
        csvDatasetTmp = csvDataset.expandDims(0).expandDims(2);
        csvDatasetTmp = tf.image.resizeBilinear(csvDatasetTmp, [1, model.inputs[0].shape[2]]);
        csvDatasetTmp = csvDatasetTmp.reshape([1, 1, model.inputs[0].shape[2]]);
        const modelOutput = await model.executeAsync(csvDatasetTmp);
        const classProbabilities = modelOutput.softmax().mul(100).arraySync();
        document.getElementById('divOutput').innerHTML = '';
        for (let i = 0; i < classProbabilities[0].length; i++) {
            document.getElementById('divOutput').innerHTML += `<div>${classNames[i]}: ${(classProbabilities[0][i]).toFixed(2)}%</div>`;
            }
        }

function disableUI(argument) {
        const nodes = document.getElementById('divInputControl').getElementsByTagName('*');
        for(let i = 0; i < nodes.length; i++){
            nodes[i].disabled = argument;
            }
        }

let model;
async function loadModel(predictFunction) {
        model = await tf.loadGraphModel(selectModel.value, {onProgress: disableUI(true)});
        if (predictFunction !== undefined) {
            predictFunction();
            }
        disableUI(false);
        }
loadModel(undefined);
</script>
  </body>
</html>